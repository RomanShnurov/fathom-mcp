# Week 1 Implementation: Configuration & Search Engine with ug+

## Overview

**Timeline**: Week 1 (Days 1-7)
**Focus**: Configuration framework, .ugrep file generation, and search engine updates
**Phases**: 1A (Configuration) + 1B (Search Engine)

---

## Goals

1. Set up configuration for 8 new document formats
2. Implement `.ugrep` configuration file generation
3. Update search engine to use `ug+` command
4. Create filter tool verification script
5. Add comprehensive tests

---

## Phase 1A: Configuration & .ugrep File Generation (Days 1-3)

### Tasks

#### 1. Update `src/contextfs/config.py`

**Add new format definitions** (all disabled by default):

```python
formats: dict[str, FormatConfig] = Field(
    default_factory=lambda: {
        # === Existing formats ===
        "pdf": FormatConfig(
            extensions=[".pdf"],
            filter="pdftotext - -",
            enabled=True,  # Already working
        ),
        "markdown": FormatConfig(
            extensions=[".md", ".markdown"],
            filter=None,
            enabled=True,
        ),
        "text": FormatConfig(
            extensions=[".txt", ".rst"],
            filter=None,
            enabled=True,
        ),

        # === NEW: Tier 1 - Office Documents ===
        "word_doc": FormatConfig(
            extensions=[".doc"],
            filter="antiword -t -w 0 %",
            enabled=False,  # Requires antiword
        ),
        "word_docx": FormatConfig(
            extensions=[".docx"],
            filter="pandoc --wrap=preserve -f docx -t plain % -o -",
            enabled=False,  # Requires pandoc
        ),
        "opendocument": FormatConfig(
            extensions=[".odt"],
            filter="pandoc --wrap=preserve -f odt -t plain % -o -",
            enabled=False,
        ),
        "epub": FormatConfig(
            extensions=[".epub"],
            filter="pandoc --wrap=preserve -f epub -t plain % -o -",
            enabled=False,
        ),
        "html": FormatConfig(
            extensions=[".html", ".htm"],
            filter="pandoc --wrap=preserve -f html -t plain % -o -",
            enabled=False,
        ),

        # === NEW: Tier 2 - Additional Formats ===
        "rtf": FormatConfig(
            extensions=[".rtf"],
            filter="pandoc --wrap=preserve -f rtf -t plain % -o -",
            enabled=False,
        ),
        "csv": FormatConfig(
            extensions=[".csv"],
            filter=None,  # Direct search
            enabled=True,  # No dependencies
        ),
        "json": FormatConfig(
            extensions=[".json"],
            filter="jq -r '.'",
            enabled=False,  # Requires jq
        ),
        "xml": FormatConfig(
            extensions=[".xml"],
            filter="pandoc --wrap=preserve -f html -t plain % -o -",
            enabled=False,
        ),
    }
)
```

**Add method to generate .ugrep configuration**:

```python
def generate_ugrep_config(self) -> str:
    """Generate .ugrep configuration file content.

    Returns:
        String content for .ugrep file
    """
    from datetime import datetime
    import shlex

    lines = [
        "### Generated by contextfs MCP server",
        f"### Knowledge root: {self.knowledge.root}",
        f"### Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        "",
        "# Document filters",
    ]

    # Add filter for each enabled format
    for fmt_name, fmt_config in self.formats.items():
        if not fmt_config.enabled or not fmt_config.filter:
            continue

        # Build extension list
        exts = ",".join(ext.lstrip(".") for ext in fmt_config.extensions)

        # Use shlex.quote for proper escaping on all platforms (Windows-safe)
        filter_spec = f"{exts}:{fmt_config.filter}"
        lines.append(f"--filter={shlex.quote(filter_spec)}")

    # Add performance settings from search config
    lines.extend([
        "",
        "# Performance settings",
        f"--context={self.search.context_lines}",
        f"--max-count={self.search.max_results}",
        "",
        "# UI preferences",
        "--color=always",
        "--line-number",
        "--with-filename",
    ])

    return "\n".join(lines) + "\n"

def get_ugrep_config_path(self) -> Path:
    """Get path for .ugrep configuration file.

    Uses temp directory to avoid modifying user's document directory.

    Returns:
        Path to .ugrep file location
    """
    import tempfile
    from pathlib import Path

    # Use temp directory with hash to make it unique per knowledge root
    root_hash = abs(hash(str(self.knowledge.root)))
    ugrep_filename = f".ugrep-contextfs-{root_hash}"
    return Path(tempfile.gettempdir()) / ugrep_filename

def write_ugrep_config(self) -> Path:
    """Write .ugrep configuration file with atomic write.

    Returns:
        Path to created .ugrep file

    Raises:
        ConfigError: If file cannot be written
    """
    import tempfile
    from contextfs.errors import ConfigError

    ugrep_path = self.get_ugrep_config_path()
    content = self.generate_ugrep_config()

    try:
        # Atomic write: write to temp file, then move
        with tempfile.NamedTemporaryFile(
            mode='w',
            encoding='utf-8',
            suffix='.ugrep',
            dir=ugrep_path.parent,
            delete=False
        ) as tmp:
            tmp.write(content)
            tmp_path = Path(tmp.name)

        # Atomic rename (POSIX) or move (Windows)
        tmp_path.replace(ugrep_path)
        logger.info(f"Generated .ugrep config at {ugrep_path}")
        return ugrep_path

    except (OSError, PermissionError) as e:
        logger.error(f"Failed to write .ugrep config to {ugrep_path}: {e}")
        raise ConfigError(f"Cannot write .ugrep configuration: {e}") from e
```

**Add helper methods**:

```python
def needs_document_filters(self) -> bool:
    """Check if any enabled formats require filter commands.

    Returns:
        True if at least one enabled format has a filter command
    """
    return any(
        fmt.enabled and fmt.filter is not None
        for fmt in self.formats.values()
    )

def get_filter_for_extension(self, ext: str) -> str | None:
    """Get filter command for a file extension.

    Args:
        ext: File extension (with or without leading dot)

    Returns:
        Filter command string, or None if no filter needed
    """
    ext = ext.lower()
    if not ext.startswith("."):
        ext = f".{ext}"

    for fmt_config in self.formats.values():
        if fmt_config.enabled and ext in fmt_config.extensions:
            return fmt_config.filter

    return None

def prepare_filter_for_stdin(self, filter_cmd: str) -> str:
    """Convert ugrep filter syntax (%) to stdin-compatible syntax (-).

    Args:
        filter_cmd: Filter command with % placeholder

    Returns:
        Filter command with stdin syntax
    """
    # Only replace % when it's used as a filename placeholder
    # ugrep uses % as the filename placeholder
    if " % " in filter_cmd:
        return filter_cmd.replace(" % ", " - ")
    elif filter_cmd.endswith(" %"):
        return filter_cmd[:-2] + " -"
    # If no %, assume stdin already
    return filter_cmd
```

#### 2. Update `config.example.yaml`

Add new formats section with examples and comments:

```yaml
# Document format configuration
formats:
  # === Office Documents (require pandoc or antiword) ===
  word_doc:
    enabled: false  # Enable after installing antiword
    filter: "antiword -t -w 0 %"
    extensions: [".doc"]
    # Install: brew install antiword (macOS) or apt install antiword (Linux)

  word_docx:
    enabled: false  # Enable after installing pandoc
    filter: "pandoc --wrap=preserve -f docx -t plain % -o -"
    extensions: [".docx"]
    # Install: brew install pandoc (macOS) or apt install pandoc (Linux)

  opendocument:
    enabled: false
    filter: "pandoc --wrap=preserve -f odt -t plain % -o -"
    extensions: [".odt"]

  epub:
    enabled: false
    filter: "pandoc --wrap=preserve -f epub -t plain % -o -"
    extensions: [".epub"]

  html:
    enabled: false
    filter: "pandoc --wrap=preserve -f html -t plain % -o -"
    extensions: [".html", ".htm"]

  rtf:
    enabled: false
    filter: "pandoc --wrap=preserve -f rtf -t plain % -o -"
    extensions: [".rtf"]

  # === Data Formats ===
  csv:
    enabled: true  # No external tools required
    filter: null
    extensions: [".csv"]

  json:
    enabled: false  # Enable after installing jq
    filter: "jq -r '.'"
    extensions: [".json"]
    # Install: brew install jq (macOS) or apt install jq (Linux)

  xml:
    enabled: false
    filter: "pandoc --wrap=preserve -f html -t plain % -o -"
    extensions: [".xml"]

# Note: When formats with filters are enabled, a .ugrep configuration file
# will be automatically generated in the system temp directory (not in your
# knowledge root, to avoid modifying your document directory).
```

#### 3. Create `scripts/verify-filters.py`

Complete filter verification script:

```python
#!/usr/bin/env python3
"""Verify filter tool installation and .ugrep configuration."""

import shutil
import subprocess
import sys
from pathlib import Path
from typing import Dict, Tuple

# Filter tools and their requirements
FILTER_TOOLS = {
    "pdftotext": {
        "package": "poppler-utils",
        "formats": ["PDF"],
        "required": True,
        "test_cmd": ["pdftotext", "-v"],
    },
    "pandoc": {
        "package": "pandoc",
        "formats": ["DOCX", "ODT", "EPUB", "HTML", "RTF", "XML"],
        "required": False,
        "test_cmd": ["pandoc", "--version"],
    },
    "antiword": {
        "package": "antiword",
        "formats": ["DOC (legacy)"],
        "required": False,
        "test_cmd": ["antiword", "-v"],
    },
    "jq": {
        "package": "jq",
        "formats": ["JSON"],
        "required": False,
        "test_cmd": ["jq", "--version"],
    },
}


def check_tool_installed(name: str) -> bool:
    """Check if tool is available in PATH."""
    return shutil.which(name) is not None


def verify_tool_works(name: str, test_cmd: list[str]) -> Tuple[bool, str]:
    """Verify tool actually works by running test command."""
    try:
        result = subprocess.run(
            test_cmd,
            capture_output=True,
            text=True,
            timeout=5,
        )
        return True, result.stdout.split("\n")[0]
    except (subprocess.TimeoutExpired, FileNotFoundError, Exception) as e:
        return False, str(e)


def verify_ugrep_config(config_path: Path) -> Tuple[bool, list[str]]:
    """Verify .ugrep configuration file."""
    issues = []

    if not config_path.exists():
        issues.append("File does not exist")
        return False, issues

    try:
        content = config_path.read_text(encoding="utf-8")
    except Exception as e:
        issues.append(f"Cannot read file: {e}")
        return False, issues

    # Check for filter lines
    filter_count = content.count("--filter=")
    if filter_count == 0:
        issues.append("No filters defined")

    # Check for generated marker
    if "Generated by contextfs" not in content:
        issues.append("Missing generation marker (may be manually edited)")

    return len(issues) == 0, issues


def main():
    print("=" * 60)
    print("ContextFS Filter Tool Verification")
    print("=" * 60)
    print()

    # Check each tool
    results = {}
    for name, info in FILTER_TOOLS.items():
        installed = check_tool_installed(name)

        if installed:
            works, version = verify_tool_works(name, info["test_cmd"])
            status = "✅ Installed" if works else "⚠️  Installed but not working"
            results[name] = works
            print(f"{status:20} {name:15} - Formats: {', '.join(info['formats'])}")
            if works and version:
                print(f"{'':20} {'':15}   Version: {version}")
        else:
            status = "❌ REQUIRED" if info["required"] else "⚠️  Optional"
            results[name] = False
            print(f"{status:20} {name:15} - Install: {info['package']}")
            print(f"{'':20} {'':15}   Formats: {', '.join(info['formats'])}")
        print()

    # Check .ugrep configuration if exists
    print("-" * 60)
    print(".ugrep Configuration File Check")
    print("-" * 60)

    # Look in common locations
    ugrep_paths = [
        Path.cwd() / ".ugrep",
        Path.home() / ".ugrep",
    ]

    found_config = False
    for ugrep_path in ugrep_paths:
        if ugrep_path.exists():
            found_config = True
            print(f"Found: {ugrep_path}")
            valid, issues = verify_ugrep_config(ugrep_path)

            if valid:
                print("✅ Configuration valid")
            else:
                print("⚠️  Configuration issues:")
                for issue in issues:
                    print(f"   - {issue}")
            print()

    if not found_config:
        print("ℹ️  No .ugrep file found (will be generated by server)")
        print()

    # Summary
    print("=" * 60)
    print("Summary")
    print("=" * 60)

    installed_count = sum(results.values())
    total_count = len(FILTER_TOOLS)

    print(f"Installed tools: {installed_count}/{total_count}")

    required_missing = [
        name for name, info in FILTER_TOOLS.items()
        if info["required"] and not results[name]
    ]

    if required_missing:
        print(f"❌ Missing required tools: {', '.join(required_missing)}")
        print()
        print("Installation commands:")
        for tool in required_missing:
            info = FILTER_TOOLS[tool]
            print(f"  macOS:  brew install {info['package']}")
            print(f"  Linux:  sudo apt install {info['package']}")
        sys.exit(1)
    else:
        print("✅ All required tools installed")

        optional_count = len([
            name for name, info in FILTER_TOOLS.items()
            if not info["required"] and results[name]
        ])
        print(f"✅ {optional_count} optional tools installed")

        if installed_count < total_count:
            print()
            print("ℹ️  To enable more formats, install:")
            for name, info in FILTER_TOOLS.items():
                if not results[name] and not info["required"]:
                    print(f"  - {name}: {info['package']}")
                    print(f"    Enables: {', '.join(info['formats'])}")

        sys.exit(0)


if __name__ == "__main__":
    main()
```

#### 4. Add Tests to `tests/test_config.py`

```python
def test_generate_ugrep_config(config):
    """Test .ugrep configuration generation."""
    # Enable some formats
    config.formats["word_docx"].enabled = True
    config.formats["epub"].enabled = True
    config.formats["json"].enabled = True

    # Generate config
    content = config.generate_ugrep_config()

    # Verify content
    assert "Generated by contextfs" in content
    assert "--filter=" in content
    assert "docx:" in content
    assert "epub:" in content
    assert "json:" in content
    assert "--context=" in content


def test_write_ugrep_config(config, tmp_path):
    """Test writing .ugrep file to disk with atomic write."""
    # Set knowledge root to temp dir
    config.knowledge.root = str(tmp_path)
    config.formats["word_docx"].enabled = True

    # Write config
    ugrep_path = config.write_ugrep_config()

    # Verify file created in temp directory (not knowledge root)
    assert ugrep_path.exists()
    assert ugrep_path.parent != tmp_path  # Should be in temp dir
    assert "ugrep-contextfs" in ugrep_path.name

    # Verify content
    content = ugrep_path.read_text()
    assert "docx:" in content


def test_needs_document_filters(config):
    """Test checking if document filters are needed."""
    # Default: pdf has filter, but let's test properly
    # Disable all formats first
    for fmt in config.formats.values():
        fmt.enabled = False

    # No filters needed
    assert not config.needs_document_filters()

    # Enable format without filter (CSV)
    config.formats["csv"].enabled = True
    assert not config.needs_document_filters()

    # Enable format with filter (DOCX)
    config.formats["word_docx"].enabled = True
    assert config.needs_document_filters()


def test_get_filter_for_extension(config):
    """Test getting filter command for extension."""
    config.formats["word_docx"].enabled = True

    # Test with dot
    assert config.get_filter_for_extension(".docx") is not None
    assert "pandoc" in config.get_filter_for_extension(".docx")

    # Test without dot
    assert config.get_filter_for_extension("docx") is not None

    # Test disabled format
    config.formats["word_docx"].enabled = False
    assert config.get_filter_for_extension(".docx") is None

    # Test unknown extension
    assert config.get_filter_for_extension(".xyz") is None


def test_prepare_filter_for_stdin(config):
    """Test filter placeholder replacement."""
    # Test with space-separated placeholder
    cmd = "pandoc --wrap=preserve -f docx -t plain % -o -"
    result = config.prepare_filter_for_stdin(cmd)
    assert result == "pandoc --wrap=preserve -f docx -t plain - -o -"

    # Test with trailing placeholder
    cmd = "antiword -t -w 0 %"
    result = config.prepare_filter_for_stdin(cmd)
    assert result == "antiword -t -w 0 -"

    # Test without placeholder
    cmd = "jq -r '.'"
    result = config.prepare_filter_for_stdin(cmd)
    assert result == "jq -r '.'"
```

### Deliverables

- [ ] All 8 new formats defined in `config.py`
- [ ] `.ugrep` file generation methods implemented
- [ ] `config.example.yaml` updated with examples
- [ ] `scripts/verify-filters.py` created and tested
- [ ] Configuration tests passing

---

## Phase 1B: Search Engine Updates (Days 4-7)

### Tasks

#### 1. Update `src/contextfs/search/ugrep.py`

**Modify `_build_command()` to use ug+**:

```python
def _build_command(
    self,
    query: str,
    path: Path,
    recursive: bool,
    context_lines: int,
    fuzzy: bool,
) -> list[str]:
    """Build ugrep command with optional ug+ for document filtering.

    Uses ug+ (ugrep with filters) when document formats with filters are enabled.
    """
    # Determine if we should use ug+ (document filtering mode)
    # Use filters only if at least one format actually requires a filter command
    use_filters = self.config.needs_document_filters()
    cmd_name = "ug+" if use_filters else "ugrep"

    cmd = [
        cmd_name,
        "-%",  # Boolean query mode
        "-i",  # Case insensitive
        f"-C{context_lines}",
        "--line-number",
        "--with-filename",
    ]

    # Add .ugrep config file path if using ug+
    if use_filters:
        ugrep_config = self.config.get_ugrep_config_path()
        if ugrep_config.exists():
            cmd.extend(["--config", str(ugrep_config)])
            logger.info(f"Using ug+ with config: {ugrep_config}")
        else:
            logger.warning(
                f".ugrep config not found at {ugrep_config}, "
                "filters may not work. Run config.write_ugrep_config()"
            )

    # Fuzzy matching
    if fuzzy:
        cmd.append("-Z")

    # Recursive search
    if recursive and path.is_dir():
        cmd.append("-r")

        # Add file extension includes
        extensions = sorted(self.config.supported_extensions)
        for ext in extensions:
            if not ext.startswith("."):
                ext = f".{ext}"
            cmd.extend(["--include", f"*{ext}"])

    # Add query and path
    cmd.append(query)
    cmd.append(str(path))

    return cmd
```

**Add fallback detection**:

```python
def _check_ug_plus_available(self) -> bool:
    """Check if ug+ command is available."""
    import shutil
    return shutil.which("ug+") is not None or shutil.which("ug") is not None
```

#### 2. Update `src/contextfs/server.py`

**Generate .ugrep on startup**:

```python
async def create_server(config: Config) -> Server:
    """Create MCP server instance.

    Args:
        config: Server configuration

    Returns:
        Configured MCP server
    """
    server = Server("contextfs")

    # Generate .ugrep configuration file
    try:
        ugrep_path = config.write_ugrep_config()
        logger.info(f"Generated .ugrep config: {ugrep_path}")
    except Exception as e:
        logger.warning(f"Failed to generate .ugrep config: {e}")

    # Register tools
    register_all_tools(server, config)

    return server
```

#### 3. Create `tests/test_formats.py`

```python
"""Tests for multi-format document support."""

import pytest
from pathlib import Path
from unittest.mock import patch, MagicMock

from contextfs.config import Config
from contextfs.search.ugrep import UgrepEngine


@pytest.mark.asyncio
async def test_ug_plus_command_generation(config, tmp_path):
    """Test that ug+ is used when formats with filters are enabled."""
    # Set knowledge root and enable formats with filters
    config.knowledge.root = str(tmp_path)
    config.formats["word_docx"].enabled = True
    config.formats["epub"].enabled = True

    # Generate .ugrep config
    ugrep_config_path = config.write_ugrep_config()

    engine = UgrepEngine(config)

    cmd = engine._build_command(
        query="test",
        path=tmp_path,
        recursive=True,
        context_lines=3,
        fuzzy=False,
    )

    # Validate command structure
    assert cmd[0] in ("ug+", "ug")  # ug+ or ug alias
    assert "-%"  in cmd  # Boolean mode
    assert "-i" in cmd   # Case insensitive
    assert "-C3" in cmd  # Context lines

    # Verify config file reference
    assert "--config" in cmd
    config_index = cmd.index("--config")
    assert cmd[config_index + 1] == str(ugrep_config_path)

    # Verify config file content
    config_content = ugrep_config_path.read_text()
    assert "--filter=" in config_content
    assert "docx:" in config_content or "epub:" in config_content


@pytest.mark.asyncio
async def test_ugrep_command_when_no_filters(config):
    """Test that ugrep is used when no formats need filters."""
    # Disable all formats with filters
    for fmt in config.formats.values():
        if fmt.filter is not None:
            fmt.enabled = False

    # Enable only non-filter formats
    config.formats["csv"].enabled = True
    config.formats["markdown"].enabled = True

    engine = UgrepEngine(config)

    cmd = engine._build_command(
        query="test",
        path=Path("/docs"),
        recursive=True,
        context_lines=3,
        fuzzy=False,
    )

    # Should use regular ugrep
    assert cmd[0] == "ugrep"
    assert "--config" not in cmd


@pytest.mark.asyncio
async def test_ugrep_config_file_usage(config, tmp_path):
    """Test that .ugrep config file is referenced correctly."""
    # Set knowledge root and create .ugrep file
    config.knowledge.root = str(tmp_path)
    config.formats["word_docx"].enabled = True
    ugrep_path = config.write_ugrep_config()

    engine = UgrepEngine(config)
    cmd = engine._build_command(
        query="test",
        path=tmp_path,
        recursive=True,
        context_lines=3,
        fuzzy=False,
    )

    # Verify config path in command
    assert "--config" in cmd
    config_index = cmd.index("--config")
    assert Path(cmd[config_index + 1]) == ugrep_path

    # Verify file is in temp directory, not knowledge root
    assert ugrep_path.parent != tmp_path


@pytest.mark.asyncio
async def test_multi_format_search_mock(config, tmp_path):
    """Test multi-format search with mocked execution."""
    config.knowledge.root = str(tmp_path)
    config.formats["word_docx"].enabled = True
    config.write_ugrep_config()

    engine = UgrepEngine(config)

    # Mock the subprocess execution
    with patch("asyncio.create_subprocess_exec") as mock_exec:
        # Mock process
        mock_process = MagicMock()
        mock_process.communicate.return_value = (
            b"test.docx:10:5:Found match in DOCX\\n",
            b""
        )
        mock_process.returncode = 0
        mock_exec.return_value = mock_process

        # Run search
        results = await engine.search(
            query="test query",
            path=tmp_path,
            recursive=True,
        )

        # Verify ug+ was called
        call_args = mock_exec.call_args[0]
        assert call_args[0] == "ug+"
```

### Deliverables

- [ ] Search engine uses `ug+` when formats enabled
- [ ] `.ugrep` config file referenced in commands
- [ ] Fallback to `ugrep` when ug+ unavailable
- [ ] .ugrep generated on server startup
- [ ] Tests passing with mocked execution
- [ ] Performance impact measured (<5% overhead)

---

## Week 1 Checklist

### Configuration (Days 1-3)
- [ ] Add 8 new format definitions to `config.py`
- [ ] Implement `generate_ugrep_config()` method with shlex.quote
- [ ] Implement `write_ugrep_config()` method with atomic write
- [ ] Implement `get_ugrep_config_path()` helper (temp directory)
- [ ] Add `needs_document_filters()` helper
- [ ] Add `get_filter_for_extension()` helper
- [ ] Add `prepare_filter_for_stdin()` helper
- [ ] Update `config.example.yaml` with examples
- [ ] Create `scripts/verify-filters.py`
- [ ] Add configuration tests
- [ ] All tests passing

### Search Engine (Days 4-7)
- [ ] Update `_build_command()` to use ug+
- [ ] Add .ugrep config file referencing
- [ ] Add fallback detection
- [ ] Update server startup to generate .ugrep
- [ ] Create `tests/test_formats.py`
- [ ] Add search tests with mocking
- [ ] Verify ug+ command generation
- [ ] All tests passing

### Documentation
- [ ] Code comments added
- [ ] Docstrings complete
- [ ] Example .ugrep file documented

### Validation
- [ ] Run `python scripts/verify-filters.py`
- [ ] Run `uv run pytest tests/test_config.py`
- [ ] Run `uv run pytest tests/test_formats.py`
- [ ] Check .ugrep file generated correctly
- [ ] Verify ug+ command in search

---

## Expected Output After Week 1

1. **Configuration**: 8 new formats defined (disabled by default)
2. **.ugrep File**: Generated in system temp directory with filters (not in knowledge root)
3. **Search**: Uses `ug+` when document formats with filters are enabled
4. **Tests**: Comprehensive mock-based tests passing
5. **Verification**: Script to check filter tool installation
6. **Windows Support**: Proper path escaping with shlex.quote
7. **Atomic Writes**: Safe .ugrep file generation with atomic write

**Ready for Week 2**: Read tool updates to use filters for document reading.
